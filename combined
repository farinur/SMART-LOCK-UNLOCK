import cv2
import mediapipe as mp
import speech_recognition as sr
import pyttsx3
import requests
import time
from datetime import datetime
import threading
import queue # For safe inter-thread communication
import numpy as np
from flask import Flask, request # For the keypad server

ESP32_CAM_IP = "192.168.1.100"  # <<< MUST REPLACE WITH our ESP32-CAM IP
ESP32_CAM_STREAM_URL = f"http://{ESP32_CAM_IP}:81/stream" # URL for the video stream ( 0 for local webcam testing)
PYTHON_SERVER_IP = "YOUR_PYTHON_PC_IP" # <<< MUST REPLACE WITH THE IP ADDRESS OF our PC
PYTHON_SERVER_PORT = 5000 # Port for the Flask server to receive keypad input

# --- Authentication Configuration ---
AUTHORIZED_PIN = "2667" 
VOICE_UNLOCK_COMMAND = "BLACK"
VOICE_LOCK_COMMAND = "YELLOW"
FACE_IMAGES_PATH = "D:/python-opencv/face _recognition/images/" 

# --- System Parameters ---
LOG_COOLDOWN_SECONDS = 5 # Log access/denial only once every X seconds
NO_FACE_TIMEOUT_SECONDS = 10 # If no faces detected for this long, trigger fallback prompt
BRIGHTNESS_THRESHOLD = 50 # Example: very dark if avg < 50 (0-255 scale)
GESTURE_COOLDOWN_SECONDS = 3 # Only detect a new gesture every 3 seconds

# --- Global State Variables ---
# Use locks for variables modified by multiple threads to prevent race conditions
door_unlocked = False
door_state_lock = threading.Lock() # Protects 'door_unlocked'

# Queues for inter-thread communication (producer-consumer pattern)
face_recognition_queue = queue.Queue() # (command, name)
keypad_input_queue = queue.Queue()     # (command, pin_or_key)
gesture_command_queue = queue.Queue()  # (command)
voice_command_queue = queue.Queue()    # (command)

# --- Speech Engine and Lock ---
engine = pyttsx3.init()
speech_lock = threading.Lock() # Ensures only one speech output at a time

def speak(text):
    """Speaks the given text, acquiring a lock to prevent overlaps."""
    with speech_lock:
        engine.say(text)
        engine.runAndWait()

# --- Logging functions ---
last_access_log_time = 0
last_failed_log_time = 0

def log_failed_attempt(method="Unknown", reason=""):
    """Logs a failed access attempt with cooldown."""
    global last_failed_log_time
    current_time = time.time()
    if current_time - last_failed_log_time > LOG_COOLDOWN_SECONDS:
        with open("failed_attempts_log.txt", "a") as log_file:
            log_file.write(f"[{datetime.now()}] ⚠️ Access Denied via {method} - Reason: {reason}\n")
        print(f"Logged: Access Denied via {method} - Reason: {reason}")
        last_failed_log_time = current_time

def log_success(name="Authorized User", method="Unknown"):
    """Logs a successful access attempt with cooldown."""
    global last_access_log_time
    current_time = time.time()
    if current_time - last_access_log_time > LOG_COOLDOWN_SECONDS:
        with open("access_log.txt", "a") as log_file:
            log_file.write(f"[{datetime.now()}] ✅ Access granted to {name} via {method}\n")
        print(f"Logged: Access granted to {name} via {method}")
        last_access_log_time = current_time

# --- Door Control Functions (Interact with ESP32) ---
def send_unlock_command():
    """Sends an HTTP GET request to unlock the door via ESP32-CAM."""
    global door_unlocked
    with door_state_lock: # Protect shared variable
        if not door_unlocked:
            try:
                requests.get(f"http://{ESP32_CAM_IP}/unlock", timeout=1)
                speak("Welcome. Door is unlocked.")
                print("ESP32 Command Sent: Door Unlocked")
                door_unlocked = True
                return True
            except requests.exceptions.ConnectionError:
                print(f"Error: Could not connect to ESP32-CAM at {ESP32_CAM_IP}. Is it online?")
                speak("Connection error to door. Cannot unlock.")
            except requests.exceptions.Timeout:
                print(f"Warning: Connection to ESP32-CAM at {ESP32_CAM_IP} timed out.")
                speak("Door connection timed out. Cannot unlock.")
            except Exception as e:
                print(f"An unexpected error occurred while communicating with ESP32-CAM: {e}")
                speak("An error occurred while trying to unlock.")
        else:
            print("Door is already unlocked. No unlock command sent.")
            speak("Door is already unlocked.")
    return False

def send_lock_command():
    """Sends an HTTP GET request to lock the door via ESP32-CAM."""
    global door_unlocked
    with door_state_lock: # Protect shared variable
        if door_unlocked: # Only try to lock if currently unlocked
            try:
                requests.get(f"http://{ESP32_CAM_IP}/lock", timeout=1)
                speak("Access denied. Door is locked.") # Or "Door is locked"
                print("ESP32 Command Sent: Door Locked")
                door_unlocked = False
                return True
            except requests.exceptions.ConnectionError:
                print(f"Error: Could not connect to ESP32-CAM at {ESP32_CAM_IP}. Is it online?")
                speak("Connection error to door. Cannot lock.")
            except requests.exceptions.Timeout:
                print(f"Warning: Connection to ESP32-CAM at {ESP32_CAM_IP} timed out.")
                speak("Door connection timed out. Cannot lock.")
            except Exception as e:
                print(f"An unexpected error occurred while communicating with ESP32-CAM: {e}")
                speak("An error occurred while trying to lock.")
        else:
            print("Door is already locked. No lock command sent.")
            speak("Door is already locked.")
    return False
